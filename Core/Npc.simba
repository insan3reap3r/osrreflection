{* Reflection Npc Functions

   This Contains all the current reflection functions relating to Npc's.



*}
  Type TNPC = Record
    Name: String;
    Tile: TPoint;
    Index, Level, NpcID: Integer;
    Animation, HitPoints: Integer;
    Interacting: Integer;
    InCombat: Boolean;
  end;
  TNPCArray = Array of TNPC;

 Var
  LocalIndexes: TintegerArray;
  DoIterate: Boolean;

(*
R_GetIndices
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetIndices:TintegerArray;

Searches npc array and returns valid npc index's. Will refresh when
the npc array is emtpy for the first run or when Npc isn't found. NOT
to be called in scripts


.. note::

  by Krazy_Meerkat

*)
function R_GetIndices:TintegerArray;
var
  i, k: Integer;
  NPCNode: integer;
begin
  if (length(LocalIndexes) = 0) or (DoIterate = true) then
  begin
    for i := 0 to 32767 do
    begin
      NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, i);
      if NPCNode = 0 then
      begin
        SmartFreeObject(SmartCurrentTarget, NPCNode);
        continue;
      end;
      Setlength(Result, (k + 1));
      Result[k] := i;
      inc(k);
      SmartFreeObject(SmartCurrentTarget, NPCNode);
    end;
    LocalIndexes := ArrayCombination(LocalIndexes, Result);
    Result:= LocalIndexes;
  end else
  Result:= LocalIndexes;
end;

(*
R_LoadNpcIndex
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_LoadNpcIndex(NPC: Variant):TintegerArray;

Searches valid index numbers Npc's with the name or Id that are
within our loaded plane by searching the loacalindexarray. The TIA containing
the Index will then be called in the rest of the functions. NOT to be called
in scripts.

.. note::

  by Elfyyy, Modified by Krazy_Meerkat

*)
function R_LoadNpcIndex(NPC: Variant):TintegerArray;
var
  i, k, s: Integer;
  NPCNode, NPCDef, NameInt, TNpcID: integer;
  Name: string;
  t, Temp: TIntegerArray;
begin
  DoIterate := False;
  T := R_GetIndices;
  s := high(T);
  Setlength(Result, s);
  k := 0;
  if length(result) = 0 then
    exit;
  for i := 0 to s do
  begin
    NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, T[i]);
    NPCDef := SmartGetFieldObject(SmartCurrentTarget, NPCNode, Npc_definition);
    if VariantIsString(NPC) then
    begin
      NameInt := SmartGetFieldObject(SmartCurrentTarget, NPCDef, NpcDefinition_name);
      Name := Lowercase(Trim(R_GetJavaString(NameInt, 512)));
      if Name = LowerCase(NPC) then
      begin
        Result[k] := T[i];
        inc(k);
      end;
      SmartFreeObject(SmartCurrentTarget, NameInt);
    end else
    begin
      TNpcID := SmartGetFieldInt(SmartCurrentTarget, NPCDef, NpcDefinition_id) * NpcDefinition_id_Multiplier;
      if TNpcID = NPC then
      begin
        Result[k] := T[i];
        inc(k);
      end;
    end;
    SmartFreeObject(SmartCurrentTarget, NPCNode);
    SmartFreeObject(SmartCurrentTarget, NPCDef);
  end;
  if k = 0 then
  begin
    DoIterate := True;
    Temp := R_GetIndices;
    Setlength(Result, length(Temp));
    DoIterate := False;
    Result := R_GetIndices;
  end;
  result:= RemoveDeadTIA(result);
end;

(*
R_GetTNPC
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetTNPC(NpcIndex: Integer): TNPC;

Returns the npc with a given index id

.. note::

  by Krazy_Meerkat

*)
function R_GetTNPC(NpcIndex: Integer): TNPC;
var
NPCNode, Def, NameInt: Integer;
begin
  NPCNode:= SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, NpcIndex);
  Def:= SmartGetFieldObject(SmartCurrentTarget, NPCNode, Npc_definition);
  NameInt := SmartGetFieldObject(SmartCurrentTarget, Def, NpcDefinition_name);
  with result do
  begin
    Name := Lowercase(Trim(R_GetJavaString(NameInt, 512)));
    Tile.x:= (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseX) * client_baseX_Multiplier) + (SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_localX) * Actor_localX_Multiplier) div 128;
    Tile.y:= (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseY) * client_baseY_Multiplier) + (SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_localY) * Actor_localY_Multiplier) div 128;
    Index:= NpcIndex;
    Level:= (SmartGetFieldInt(SmartCurrentTarget, Def, NpcDefinition_level ) * NpcDefinition_level_Multiplier);
    NpcID:= SmartGetFieldInt(SmartCurrentTarget, Def, NpcDefinition_id) * NpcDefinition_id_Multiplier;
    Animation:= SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_animation)  * Actor_animation_Multiplier;
    HitPoints:= ((SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_health) * Actor_health_Multiplier) / 30);
    if (HitPoints < 0) then
      HitPoints:= 0;
    Interacting:= SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_interacting) * Actor_interacting_Multiplier;
    if ((Animation > -1) or (HitPoints > 0)) then
      InCombat:= True
    else
      InCombat:= False;
  end;
  SmartFreeObject(SmartCurrentTarget, NPCNode);
  SmartFreeObject(SmartCurrentTarget, Def);
  SmartFreeObject(SmartCurrentTarget, NameInt);
end;

(*
R_SortNPCs
~~~~~~~~~~

.. code-block:: pascal

    R_SortNPCs(NPCs: TNPCArray): TNPCArray;

Sorts NPCs by distance from you.

.. note::

  by Widget, Modified by Lordsaturn

*)
function R_SortNPCs(NPCs: TNPCArray): TNPCArray;
var
  i,i2, L: integer;
  tpa: TPointArray;
begin
  L := GetArrayLength(NPCs);
  if L < 1 then Exit;
  SetArrayLength(TPA, L);
  SetArrayLength(Result, L);
  for i := 0 to L-1 do
    TPA[i] := NPCs[i].Tile;
  SortTPAFrom(TPA, R_GetTileGlobal);
  for i := 0 to L-1 do
    for i2 := 0 to L-1 do
      if (TPA[i].x=NPCs[i2].Tile.x) and (TPA[i].y=NPCs[i2].Tile.y) then
        Result[i] := NPCs[i2];
end;

(*
R_GetNpcs
~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcs(NPC: variant): array of TNPC;

   Returns all data in a TNPCArray for npc with given name or id.

.. note::

  by Elfyyy

*)
function R_GetNpcs(NPC: variant): array of TNPC;
var
Npcs: TIntegerArray;
h, i: integer;
begin
  Npcs := R_LoadNpcIndex(NPC)
  h := high(Npcs);
  Setlength(Result, h + 1);
  for i := 0 to h do
  begin
    result[i]:= R_GetTNPC(Npcs[i]);
  end;
  R_SortNPCs(Result);
end;

(*
R_FindNpc
~~~~~~~~~~

.. code-block:: pascal

    R_FindNpc(NPC: variant; var TheNPC: TNPC): Boolean;

   Returns true if the Npc specified by the variant NPC is found
   and stores it in TheNPC.

.. note::

  by Elfyyy

*)
function R_FindNpc(NPC: variant; var TheNPC: TNPC): Boolean;
var
temp: TNPCArray;
begin
  result := False;
  temp := R_GetNpcs(NPC);
  if length(temp) = 0 then
    exit;
  result := true;
  TheNpc := temp[0];
end;

(*
R_InteractingNpc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_InteractingNpc:TNPC;

Returns the npc we are interacting with.
If none, the npc's values will be 0

.. note::

  by Krazy_Meerkat

*)
function R_InteractingNpc:TNPC;
var
Local, InteractingIndex: Integer;
begin
  Local:= SmartGetFieldObject(SmartCurrentTarget, 0, client_player);
  InteractingIndex:= SmartGetFieldInt(SmartCurrentTarget, Local, Actor_interacting) * Actor_interacting_Multiplier;
  SmartFreeObject(SmartCurrentTarget, Local);
  result:= R_GetTNPC(InteractingIndex);
end;

(*
R_FindFreeNpc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_FindFreeNpc(NPC: variant):TNPC;

Finds the closest npc with the given name which isn't in combat

.. note::

  by Krazy_Meerkat

*)
function R_FindFreeNpc(NPC: variant):TNPC;
var
i: Integer;
temp: TNPCArray;
begin
  temp := R_GetNpcs(NPC);
  for i:= 0 to high(temp) do
  begin
    if not(temp[i].InCombat) then
    begin
      result:= temp[i];
      break;
    end;
  end;
end;
