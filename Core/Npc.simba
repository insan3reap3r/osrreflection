{* Reflection Npc Functions

   This Contains all the current reflection functions relating to Npc's.



*}
 Var
  LocalIndexes: TintegerArray;
  DoIterate: Boolean;

(*
R_GetIndices
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetIndices:TintegerArray;

Searches npc array and returns valid npc index's. Will refresh when
the npc array is emtpy for the first run or when Npc isn't found. NOT
to be called in scripts


.. note::

  by Krazy_Meerkat

*)
function R_GetIndices:TintegerArray;
var
  i, k: Integer;
  NPCNode: integer;
begin
  if (length(LocalIndexes) = 0) or (DoIterate = true) then
  begin
    for i := 0 to 32767 do
    begin
      NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, i);
      if NPCNode = 0 then
      begin
        SmartFreeObject(SmartCurrentTarget, NPCNode);
        continue;
      end;
      Setlength(Result, (k + 1));
      Result[k] := i;
      inc(k);
      SmartFreeObject(SmartCurrentTarget, NPCNode);
    end;
    LocalIndexes := ArrayCombination(LocalIndexes, Result);
    Result:= LocalIndexes;
  end else
  Result:= LocalIndexes;
end;

(*
R_LoadNpcIndex
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_LoadNpcIndex(NPC: Variant):TintegerArray;

Searches valid index numbers Npc's with the name or Id that are
within our loaded plane by searching the loacalindexarray. The TIA containing
the Index will then be called in the rest of the functions. NOT to be called
in scripts.

.. note::

  by elfyyy, Modified by Krazy_Meerkat

*)
function R_LoadNpcIndex(NPC: Variant):TintegerArray;
var
  i, k, s: Integer;
  TheNPC, NPCNode, NPCDef, NameInt, NpcID: integer;
  Name: string;
  t, FoundNpcs, Temp: TIntegerArray;
begin
  DoIterate := False;
  T := R_GetIndices;
  s := high(T);
  Setlength(Result, s);
  k := 0;
  if length(result) = 0 then
    exit;
  for i := 0 to s do
  begin
    NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, T[i]);
    NPCDef := SmartGetFieldObject(SmartCurrentTarget, NPCNode, Npc_definition);
    if VariantIsString(NPC) then
    begin
      NameInt := SmartGetFieldObject(SmartCurrentTarget, NPCDef, NpcDefinition_name);
      Name := Lowercase(Trim(R_GetJavaString(NameInt, 512)));
      if Name = LowerCase(NPC) then
      begin
        Result[k] := T[i];
        inc(k);
      end;
    end else
    begin
      NpcID := SmartGetFieldInt(SmartCurrentTarget, NPCDef, NpcDefinition_id) * NpcDefinition_id_Multiplier;
      if NpcID = NPC then
      begin
        Result[k] := T[i];
        inc(k);
      end;
    end;
    SmartFreeObject(SmartCurrentTarget, NPCNode);
    SmartFreeObject(SmartCurrentTarget, TheNPC);
    SmartFreeObject(SmartCurrentTarget, NPCDef);
    SmartFreeObject(SmartCurrentTarget, NameInt);
  end;
  if k = 0 then
  begin
    DoIterate := True;
    Temp := R_GetIndices;
    Setlength(Result, length(Temp));
    Result := R_GetIndices;
    DoIterate := False;
  end;
  result:= RemoveDeadTIA(result);
end;

(*
R_InteractingNpc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_InteractingNpc:integer;

Returns index of npc we are interacting with. If none, Result = -1

.. note::

  by elfyyy

*)
function R_InteractingNpc:integer;
var
local: integer;
begin
  Local := SmartGetFieldObject(SmartCurrentTarget, 0, client_player);
  result := SmartGetFieldInt(SmartCurrentTarget, Local, Actor_interacting) * Actor_interacting_Multiplier;
  SmartFreeObject(SmartCurrentTarget, Local);
end;

(*
R_GetNpcAnimation
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcAnimation(NPC: Variant):integer;

Gets animation of npc we are interacting with. 0 = No Npc is interacting, -1 = No animation of Npc

.. note::

  by elfyyy

*)
function R_GetNpcAnimation:integer;
var
  NPCNode, IndexId: Integer;
begin
  IndexId := R_InteractingNpc
  NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, IndexID);
  Result := SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_animation)  * Actor_animation_Multiplier;
  if result > 10000 then
    result := 0;
  SmartFreeObject(SmartCurrentTarget, NPCNode);
end;

(*
R_GetNpcsLoc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcsLoc(NPC: Variant):TPointArray;

Returns all nearby Npc's Current Location with the Name given and stores
it in a TPA with closest first.


.. note::

  by elfyyy

*)
function R_GetNpcsLoc(NPC: Variant):TPointArray;
var
  i, l, BaseX, BaseY, NPCNode, Def: Integer;
  s : TIntegerArray;
begin
  BaseX := (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseX) * client_baseX_Multiplier);
  BaseY := (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseY) * client_baseY_Multiplier);
  s := R_LoadNpcIndex(NPC);
  l := high(s);
  SetLength(Result, 100);
  for i := 0 to l do
  begin
    NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, s[i]);
    Def := SmartGetFieldObject(SmartCurrentTarget, NPCNode, Npc_definition);
    if Def = 0 then
    begin
      SmartFreeObject(SmartCurrentTarget, NPCNode);
      SmartFreeObject(SmartCurrentTarget, Def);
      continue;
    end;
    result[i].x := (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseX) * client_baseX_Multiplier) + (SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_localX) * Actor_localX_Multiplier) div 128;
    result[i].y := (SmartGetFieldInt(SmartCurrentTarget, 0, client_baseY) * client_baseY_Multiplier) + (SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_localY) * Actor_localY_Multiplier) div 128;
    SmartFreeObject(SmartCurrentTarget, NPCNode);
    SmartFreeObject(SmartCurrentTarget, Def);
  end;
  SortTpaFrom(Result, Point(10000,10000));
  result:= RemoveDeadTPA(result);
  SortTpaFrom(Result,R_GetTileGlobal);
end;

(*
R_GetNpcLoc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcLoc(NPC: Variant):TPoint;

Returns Location npc with given name or ID.

.. note::

  by elfyyy

*)
function R_GetNpcLoc(NPC: Variant):TPoint;
var
  temp: TPointArray;
  Loc: Tpoint;
begin
  Temp := R_GetNpcsLoc(NPC);
  if length(Temp) = 0 then
    exit;
  Loc := R_GetTileGlobal;
  SortTpaFrom(Temp, Loc);
  Result := Temp[0];
end;

(*
R_GetNpcHp
~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_GetNpcHp:integer;

Returns Current hp of npc in combat with us. Returns -1 if none are
currently in combat with us

.. note::

  by elfyyy

*)
function R_GetNpcHp:integer;
var
  Mid, NPCNode, IndexId: Integer;

begin
  IndexId := R_InteractingNpc;
  NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, IndexID);
  Mid := ((SmartGetFieldInt(SmartCurrentTarget, NPCNode, Actor_health) * Actor_health_Multiplier) / 30);
  if Mid < 0 then
  begin
    result := 0;
    SmartFreeObject(SmartCurrentTarget, NPCNode);
    exit;
  end;
  Result := Mid;
  SmartFreeObject(SmartCurrentTarget, NPCNode);
  if result > 1000 then
    Result := -1;
end;

(*
R_NpcLevel
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_NpcLevel(NPC: Variant):integer;

Returns Combat level of npc with given name or ID.

.. note::

  by elfyyy

*)
function R_NpcLevel(NPC: Variant):integer;
var
  NPCNode, Def: Integer;
  IndexId: TIntegerArray;
begin
  IndexId := R_LoadNpcIndex(NPC);
  if length(IndexId) = 0 then
    exit;
  NPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, client_npcs, IndexID[0]);
  Def := SmartGetFieldObject(SmartCurrentTarget, NPCNode, Npc_definition);
  Result := (SmartGetFieldInt(SmartCurrentTarget, Def, NpcDefinition_level ) * NpcDefinition_level_Multiplier);
  SmartFreeObject(SmartCurrentTarget, NPCNode);
  SmartFreeObject(SmartCurrentTarget, Def);
end;

(*
R_InCombat
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_InCombat:boolean;

 Returns True If in combat with an Npc.

.. note::

  by elfyyy

*)
function R_InCombat:Boolean;
begin
  result := (R_GetNpcAnimation <> 0);
end;
