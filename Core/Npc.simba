{* Reflection Npc Functions

   This Contains all the current reflection functions relating to Npc's.



*}

(*
R_GetIndices
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetIndices:TIntegerArray;

Searches for valid npc index to be used later. Not to be called in scripts.

.. note::

  by elfyyy

*)
function R_GetIndices:TIntegerArray;
var
 i: integer;
begin
  SetLength(Result, 150);
  repeat
  inc(i)
  Result[i] := SmartGetFieldArrayint(SmartCurrentTarget, 0, HookNPCIndex, i);
  if Result[i] = 0 then
  begin
    SetLength(result, i);
    exit;
  end;
  until(i = 50);
end;

(*
R_LoadNpcIndex
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_LoadNpcIndex(Name: string):TintegerArray;

Searches valid index numbers Npc's with the name given by "Npcname" that are
within our loaded plane(around 20-30 tiles) The TIA containing the Index will
then be called in the rest of the functions. NOT to be called in scripts.

.. note::

  by elfyyy

*)
function R_LoadNpcIndex(NpcName: string):TintegerArray;
var
  i, k, s: Integer;
  TheNPC, TheNPCNode, NPCDef, TheBytes: integer;
  TheName: string;
  t: TIntegerArray;
begin
  Setlength(Result, 100);
  s := high(R_GetIndices)
  T := R_GetIndices;
  k := 0;
  for i := 0 to s do
  begin
    TheNPCNode := SmartGetFieldArrayObject(SmartCurrentTarget, 0, HookNPCs, T[i]);
    NPCDef := SmartGetFieldObject(SmartCurrentTarget, TheNPCNode, HookNPCDef);
    TheBytes := SmartGetFieldObject(SmartCurrentTarget, NPCDef, HookNPCName);
    TheName := Lowercase(Trim(R_GetJavaString(TheBytes, 512)));
    if TheName = '' then
    begin
      SmartFreeObject(SmartCurrentTarget, TheNPCNode);
      SmartFreeObject(SmartCurrentTarget, TheNPC);
      SmartFreeObject(SmartCurrentTarget, NPCDef);
      SmartFreeObject(SmartCurrentTarget, TheBytes);
      continue;
    end;
    begin
      if TheName = LowerCase(NpcName) then
      begin
      Result[k] := T[i];
      inc(k);
      end;
    end;
    SmartFreeObject(SmartCurrentTarget, TheNPCNode);
    SmartFreeObject(SmartCurrentTarget, TheNPC);
    SmartFreeObject(SmartCurrentTarget, NPCDef);
    SmartFreeObject(SmartCurrentTarget, TheBytes);
  end;
  result:= RemoveDeadTIA(result);
end;

(*
R_GetNpcsLoc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcsLoc(NpcName:String):TPointArray;

Returns all nearby Npc's Current Location with the Name given and stores
it in a TPA with closest first.


.. note::

  by elfyyy

*)
function R_GetNpcsLoc(NpcName:String):TPointArray;
var
  i, l, BaseX, BaseY, Node, Def: Integer;
  s : TIntegerArray;
begin
  BaseX := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseX) * HookGetBaseXMultiplier);
  BaseY := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseY) * HookGetBaseYMultiplier);
  l := high(R_LoadNpcIndex(NpcName));
  s := R_LoadNpcIndex(NpcName);
  SetLength(Result, 100);
  for i := 0 to l do
  begin
    Node := SmartGetFieldArrayObject(SmartCurrentTarget, 0, HookNPCs, s[i]);
    Def := SmartGetFieldObject(SmartCurrentTarget, Node, HookNPCDef);
    if Def = 0 then
    begin
      SmartFreeObject(SmartCurrentTarget, Node);
      SmartFreeObject(SmartCurrentTarget, Def);
      continue;
    end;
    result[i].x := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseX) * HookGetBaseXMultiplier) + (SmartGetFieldInt(SmartCurrentTarget, Node, HookCharacterX) * HookCharacterXMultiplier) div 128;
    result[i].y := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseY) * HookGetBaseYMultiplier) + (SmartGetFieldInt(SmartCurrentTarget, Node, HookCharacterY) * HookCharacterYMultiplier) div 128;
    SmartFreeObject(SmartCurrentTarget, Node);
    SmartFreeObject(SmartCurrentTarget, Def);
  end;
  SortTpaFrom(Result, Point(10000,10000));
  result:= RemoveDeadTPA(result);
  SortTpaFrom(Result,R_GetTileGlobal);
end;

(*
R_GetNpcLoc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_GetNpcLoc(NpcName:String):TPoint;

Returns Location of closest npc with given name.

.. note::

  by elfyyy

*)
function R_GetNpcLoc(NpcName:String):TPoint;
var
  temp: TPointArray;
  Loc: Tpoint;
begin
  Temp := R_GetNpcsLoc(NpcName);
  if length(Temp) = 0 then
    exit;
  Loc := R_GetTileGlobal;
  SortTpaFrom(Temp, Loc);
  Result := Temp[0];
end;

(*
R_InteractingNpc
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_InteractingNpc:integer;

Returns index of npc we are interacting with.

.. note::

  by elfyyy

*)
function R_InteractingNpc:integer;
var
local: integer;
begin
  Local := SmartGetFieldObject(SmartCurrentTarget, 0, HookLocalPlayer);
  result := SmartGetFieldInt(SmartCurrentTarget, Local, HookInteracting) * HookInteractingMultiplier;
  SmartFreeObject(SmartCurrentTarget, Local);
end;


(*
R_GetNpcHp
~~~~~~~~~~~~~~

.. code-block:: pascal

    function R_GetNpcHp:integer;

Returns Current hp of npc in combat with us.

.. note::

  by elfyyy

*)
function R_GetNpcHp:integer;
var
  Mid, Node, IndexId: Integer;

begin
  IndexId := R_InteractingNpc;
  Node := SmartGetFieldArrayObject(SmartCurrentTarget, 0, HookNPCs, IndexID);
  Mid := ((SmartGetFieldInt(SmartCurrentTarget, Node, HookGethealth) * HookgethealthMultiplier) / 30);
  if Mid < 0 then
  begin
    result := 0;
    SmartFreeObject(SmartCurrentTarget, Node);
    exit;
  end;
  Result := Mid;
  SmartFreeObject(SmartCurrentTarget, Node);
end;

(*
R_NpcLevel
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_NpcLevel(NpcName: String):integer;

Returns Combat level of nearest npc to player with given name.

.. note::

  by elfyyy

*)
function R_NpcLevel(NpcName: String):integer;
var
  Node, Def: Integer;
  IndexId: TIntegerArray;
begin
  IndexId := R_LoadNpcIndex(NpcName);
  if length(IndexId) = 0 then
    exit;
  Node := SmartGetFieldArrayObject(SmartCurrentTarget, 0, HookNPCs, IndexID[0]);
  Def := SmartGetFieldObject(SmartCurrentTarget, Node, HookNPCDef);
  Result := (SmartGetFieldInt(SmartCurrentTarget, Def, HookNPCLevel ) * HookNPCLevelMultiplier);
  SmartFreeObject(SmartCurrentTarget, Node);
  SmartFreeObject(SmartCurrentTarget, Def);
end;

(*
R_InCombat
~~~~~~~~~~~~~~

.. code-block:: pascal

    R_InCombat:boolean;

 Returns True If in combat with an Npc.

.. note::

  by elfyyy

*)
function R_InCombat:Boolean;
begin
  result := false;
  if (R_InteractingNpc > -1) and (R_GetAnimation > -1) then
    result := true;
end;
