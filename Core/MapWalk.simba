
(*
R_TileOnMM
~~~~~~~~~~

.. code-block:: pascal

    function R_TileOnMM(Tile: TPoint): boolean;

Checks if the Tile is on the MM.

.. note::

  by Drags111

*)
function R_TileOnMM(Tile: TPoint): boolean;
var
  P: TPoint;
begin
  P := R_TileToMM(Tile);
  Result := rs_OnMinimap(P);
end;

(*
R_WalkToTile
~~~~~~~~~~

.. code-block:: pascal

    function R_WalkToTile(Tile: TPoint): boolean;

Walks to specified Tile, Returns true once clicked and doesn't wait until
we stop.

.. note::

  by elfyyy

*)
function R_WalkToTile(Tile: TPoint): boolean;
var
  P: TPoint;
begin
  Result := False;
  if not R_TileOnMM(Tile) then
    exit;
  P := R_TileToMM(Tile);
  Mmouse(P.x, P.y, 0, 0);
  Wait(RandomRange(150, 220));
  ClickMouse2(Mouse_Left);
  result := True;
end;

(*
R_WalkPath
~~~~~~~~~~~

.. code-block:: pascal

    function R_WalkPath(Path: TPointArray): boolean;

Walks the path specified in a human like manner.

.. note::

  by AwkwardSaw, Modified By elfyyy

*)
function R_WalkPath(Path: TPointArray): boolean;
var
  I, K, H, T, D, Fails, lP: integer;
  P, MM, MMF: TPoint;
begin
  ColorToleranceSpeed(1);
  H := High(Path);
  T := GetSystemTime + 10000 + Random(2000);
  Fails := 0;
  lP := 0;
  while (not Result) and (GetSystemTime < T) and (Fails < 5) do
  begin
    if (not LoggedIn()) then
      Exit;
    P := R_GetTileGlobal;
    for I := H downto 0 do
    begin
      if ((I - lP) > 3) then
        Continue
      else
        lP := I;
      MM := R_TileToMM(Path[I]);
      if MM = MMF then
        Inc(Fails);
      if (R_DistanceFromTile(Path[i]) < 10) then
        break;
      if R_TileOnMM(Path[i]) then
      begin
        R_WalkToTile(Path[i]);
        MarkTime(K);
        repeat
        if not R_IsWalking then
          break;
        until(TimeFromMark(K) > 2000);
        MMF := MM;
        if (I = H) then
          FFlag(5)
        else
          FFlag(25);
        T := getSystemTime + 7000 + Random(1000);
        Break;
      end;
    end;
    Result := (I = H);
  end;
  FFlag(5);
end;

(*
R_BlindWalk
~~~~~~~~~~~

.. code-block:: pascal

    function R_BlindWalk(P: TPoint): Boolean;

Uses R_WalkPath and creates a path in a straight line to walk from current
tile to tile specified.

.. note::

  by Flight

*)
function R_BlindWalk(P: TPoint): Boolean;
var
  Tries, Fails: Integer;
  M: TPoint;
  ctrlPoints: TPointArray;
begin
  repeat
    inc(Fails);
    if Fails > 1 then
      exit;
    if (not LoggedIn()) then
      Exit;
    M := R_GetTileGlobal;
    if (M.X = - 1) then
      Continue;
    if (Length(ctrlPoints) = 0) then
      ctrlPoints := TPABetweenPoints(M, P, 5 + Random(2), 2);
    Inc(Tries);
    if (Tries > 20) then
      Exit;
    Result := R_WalkPath(ctrlPoints);
  until (Result);
end;

(*
R_GetToTile
~~~~~~~~~~~

.. code-block:: pascal

    R_GetToTile(TheTile, NextPoint: TPoint): Boolean;

Walks to the tile using the minimap and reflection.

.. note::

  by Krazy_Meerkat

*)
function R_GetToTile(TheTile, NextPoint: TPoint): Boolean;
var
   msTile: TPoint;
   t: Integer;
begin
  Result := false;
  msTile := R_TileToMM(TheTile);
  if not(rs_OnMiniMap(msTile)) then
    Exit;
  t := getsystemtime;
  if (NextPoint.x = -1) then
  begin
    repeat
      msTile := R_TileToMM(TheTile);
      Mouse(msTile.x, msTile.y, 1, 1, true);
      Wait(RandomRange(80, 100));
      if (not(R_IsWalking)) then
      begin
        repeat
          FindNormalRandoms;
          wait(50+random(50));
        until(R_IsWalking or ((GetSystemTime - t) > (1000+random(500))));
      end;
      repeat
        FindNormalRandoms;
        wait(50+random(50));
      until(not(R_IsWalking));
    until((R_NearTile(TheTile, 5)) or ((GetSystemTime - t) > 59999));
  end;
  if (NextPoint.x > -1) then
  begin
    repeat
      msTile := R_TileToMM(TheTile);
      Mouse(msTile.x, msTile.y, 1, 1, true);
      Wait(RandomRange(80, 100));
      if (not(R_IsWalking)) then
      begin
        repeat
          FindNormalRandoms;
          wait(50+random(50));
        until(R_IsWalking or ((GetSystemTime - t) > (1000+random(500))));
      end;
      repeat
        FindNormalRandoms;
        wait(50+random(50));
      until((R_NearTile(TheTile, 5) and R_TileOnMM(NextPoint)) or not(R_IsWalking));
    until((R_NearTile(TheTile, 5) and R_TileOnMM(NextPoint)) or ((GetSystemTime - t) > 59999));
  end;
  Result := (GetSystemTime - t) < 60000;
end;

(*
R_WindPath
~~~~~~~~~~~

.. code-block:: pascal

    R_WindPath(xs, ys, xe, ye, gravity, wind, minWait, maxWait, maxStep, targetArea: extended): TPointArray;

Generates a blind path of points!

.. note::

  by JuKKa

*)
function R_WindPath(xs, ys, xe, ye, gravity, wind, minWait, maxWait, maxStep, targetArea: extended): TPointArray;
var
  veloX, veloY, windX, windY, veloMag, dist, randomDist, lastDist, step: extended;
  lastX, lastY: integer;
  sqrt2, sqrt3, sqrt5: extended;
begin
  sqrt2:= sqrt(2);
  sqrt3:= sqrt(3);
  sqrt5:= sqrt(5);
  while hypot(xs - xe, ys - ye) > 1 do
  begin
    dist:= hypot(xs - xe, ys - ye);
    wind:= minE(wind, dist);
    if dist >= targetArea then
    begin
      windX:= windX / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
      windY:= windY / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
    end else
    begin
      windX:= windX / sqrt2;
      windY:= windY / sqrt2;
      if (maxStep < 3) then
      begin
        maxStep:= random(3) + 3.0;
      end else
      begin
        maxStep:= maxStep / sqrt5;
      end;
    end;
    veloX:= veloX + windX;
    veloY:= veloY + windY;
    veloX:= veloX + gravity * (xe - xs) / dist;
    veloY:= veloY + gravity * (ye - ys) / dist;
    if hypot(veloX, veloY) > maxStep then
    begin
      randomDist:= maxStep / 2.0 + random(round(maxStep) / 2);
      veloMag:= sqrt(veloX * veloX + veloY * veloY);
      veloX:= (veloX / veloMag) * randomDist;
      veloY:= (veloY / veloMag) * randomDist;
    end;
    lastX:= Round(xs);
    lastY:= Round(ys);
    xs:= xs + veloX;
    ys:= ys + veloY;
    SetArrayLength(Result, GetArrayLength(Result) + 1);
    Result[ High(Result) ] := Point(Round(xs), Round(ys));
    step:= hypot(xs - lastX, ys - lastY);
    lastdist:= dist;
  end;
end;

(*
R_WebWalk
~~~~~~~~~~~

.. code-block:: pascal

    R_WebWalk(T: TPoint): Boolean;

Walks blindly using WindPath!

.. note::

  by JuKKa, Modified by Krazy_Meerkat

*)
function R_WebWalk(T: TPoint): Boolean;
var
  I: Integer;
  M: TPoint;
  CTRLPoints: TPointArray;
begin
  Result:= false;
  repeat
    M := R_GetTileGlobal;
    CtrlPoints := r_WindPath(M.x, M.y, T.X, T.Y, 5.0, 2.5, 0.0, 0.0, 4.5, 2.5);
    for I:= High(CtrlPoints) DownTo 0 Do
      if (I = 0) then
      begin
        if R_GetToTile(CtrlPoints[i], Point(-1,-1)) Then
        begin
          Result := I = High(CtrlPoints);
          Break;
        end;
      end else
      begin
        if R_GetToTile(CtrlPoints[i], CtrlPoints[i-1]) Then
        begin
          Result := I = High(CtrlPoints);
          Break;
        end;
      end;
  until(Result);
end;

(*
R_PerfectPath
~~~~~~~~~~~

.. code-block:: pascal

    R_PerfectPath(Path: TPointArray);

Walks the path like a human would, if a point isn't visible on the MM it
uses WebWalk until the point becomes visable. It's recommended that you
don't put your points too close-together in a path, for best results
keep points at least 5 tiles away from adjacent points (walk at least 5
tiles away when making the path).

.. note::

  by Krazy_Meerkat

*)
procedure R_PerfectPath(Path: TPointArray);
var
  i: Integer;
begin
  for i:= 0 to High(Path) do
  begin
    if (i = High(Path)) then
    begin
      repeat
        wait(100+random(50));
        if not(R_TileOnMM(Path[i])) then
          R_WebWalk(Path[i]);
      until(R_GetToTile(Path[i], Point(-1,-1)));
    end else
    begin
      repeat
        wait(100+random(50));
        if not(R_TileOnMM(Path[i])) then
          R_WebWalk(Path[i]);
      until(R_GetToTile(Path[i], Path[i+1]));
    end;
  end;
end;
