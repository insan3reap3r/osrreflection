
(*
R_TileOnMM
~~~~~~~~~~

.. code-block:: pascal

    function R_TileOnMM(Tile: TPoint): boolean;

Checks if the Tile is on the MM.

.. note::

  by Drags111

*)
function R_TileOnMM(Tile: TPoint): boolean;
var
  P: TPoint;
begin
  P := R_TileToMM(Tile);
  Result := rs_OnMinimap(P);
end;

(*
R_WalkToTile
~~~~~~~~~~

.. code-block:: pascal

    function R_WalkToTile(Tile: TPoint): boolean;

Walks to specified Tile, Returns true once clicked and doesn't wait until
we stop.

.. note::

  by elfyyy

*)
function R_WalkToTile(Tile: TPoint): boolean;
var
  P: TPoint;
begin
  Result := False;
  if not R_TileOnMM(Tile) then
    exit;
  P := R_TileToMM(Tile);
  Mmouse(P.x, P.y, 0, 0);
  Wait(RandomRange(150, 220));
  ClickMouse2(Mouse_Left);
  result := True;
end;

(*
R_WalkPath
~~~~~~~~~~~

.. code-block:: pascal

    function R_WalkPath(Path: TPointArray): boolean;

Walks the path specified in a human like manner.

.. note::

  by AwkwardSaw, Modified By elfyyy

*)
function R_WalkPath(Path: TPointArray): boolean;
var
  I, K, H, T, D, Fails, lP: integer;
  P, MM, MMF: TPoint;
begin
  ColorToleranceSpeed(1);
  H := High(Path);
  T := GetSystemTime + 10000 + Random(2000);
  Fails := 0;
  lP := 0;
  while (not Result) and (GetSystemTime < T) and (Fails < 5) do
  begin
    if (not LoggedIn()) then
      Exit;
    P := R_GetTileGlobal;
    for I := H downto 0 do
    begin
      if ((I - lP) > 3) then
        Continue
      else
        lP := I;
      MM := R_TileToMM(Path[I]);
      if MM = MMF then
        Inc(Fails);
      if (R_DistanceFromTile(Path[i]) < 10) then
        break;
      if R_TileOnMM(Path[i]) then
      begin
        R_WalkToTile(Path[i]);
        MarkTime(K);
        repeat
        if not R_IsWalking then
          break;
        until(TimeFromMark(K) > 2000);
        MMF := MM;
        if (I = H) then
          FFlag(5)
        else
          FFlag(25);
        T := getSystemTime + 7000 + Random(1000);
        Break;
      end;
    end;
    Result := (I = H);
  end;
  FFlag(5);
end;

(*
R_BlindWalk
~~~~~~~~~~~

.. code-block:: pascal

    function R_BlindWalk(P: TPoint): Boolean;

Uses R_WalkPath and creates a path in a straight line to walk from current
tile to tile specified.

.. note::

  by Flight

*)
function R_BlindWalk(P: TPoint): Boolean;
var
  Tries, Fails: Integer;
  M: TPoint;
  ctrlPoints: TPointArray;
begin
  repeat
    inc(Fails);
    if Fails > 1 then
      exit;
    if (not LoggedIn()) then
      Exit;
    M := R_GetTileGlobal;
    if (M.X = - 1) then
      Continue;
    if (Length(ctrlPoints) = 0) then
      ctrlPoints := TPABetweenPoints(M, P, 5 + Random(2), 2);
    Inc(Tries);
    if (Tries > 20) then
      Exit;
    Result := R_WalkPath(ctrlPoints);
  until (Result);
end;
