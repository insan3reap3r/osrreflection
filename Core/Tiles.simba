


(*
R_GetTileGlobal
~~~~~~~~~~~

.. code-block:: pascal

    function R_GetTileGlobal: TPoint;

Returns the current location of player.

.. note::

  by Brandon

*)
function R_GetTileGlobal: TPoint;
var
  Me: Integer;
begin
  Me := SmartGetFieldObject(SmartCurrentTarget, 0, HookLocalPlayer);
  Result.X := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseX) * HookGetBaseXMultiplier) + (SmartGetFieldInt(SmartCurrentTarget, Me, HookCharacterX) * HookCharacterXMultiplier) div 128;
  Result.Y := (SmartGetFieldInt(SmartCurrentTarget, 0, HookGetBaseY) * HookGetBaseYMultiplier) + (SmartGetFieldInt(SmartCurrentTarget, Me, HookCharacterY) * HookCharacterYMultiplier) div 128;
  SmartFreeObject(SmartCurrentTarget, Me);
end;

(*
R_TileToMM
~~~~~~~~~~~

.. code-block:: pascal

    function R_TileToMM(tile: TPoint): TPoint;

Converts the global tile position to a screen location on the
  minimap, taking map rotation into account.

.. note::

  by BenLand100, Modified by Krazy_Meerkat

*)
function R_TileToMM(tile: TPoint): TPoint;
var
  Angle, x, y: extended;
  temp: TPoint;
begin
  Angle := -R_GetMinimapAngleRad;
  temp := R_GetTileGlobal;
  x := (tile.x - temp.x) * 4 - 2;
  y := (temp.y - tile.y) * 4 - 2;
  result.x := round((x * cos(angle)) + (y * sin(angle))) + 643;
  result.y := round((y * cos(angle)) - (x * sin(angle))) + 83;
end;

(*
R_NearTile
~~~~~~~~~~~

.. code-block:: pascal

    function R_NearTile(Tile: TPoint; Distance: Integer): Boolean;

Returns true if player is within the distance specified to the tile.

.. note::

  by elfyyy

*)
function R_NearTile(TP:Tpoint; Dist:integer):Boolean;
var
  Loc: TPoint;
begin
  result := False;
  Loc := R_GetTileGlobal
  if Distance(TP.x, TP.y, Loc.x, Loc.y) < Dist then
    Result := True;
end;

(*
R_OnTile
~~~~~~~~~~~

.. code-block:: pascal

    function R_OnTile(TP:Tpoint):Boolean;

Returns true if player is on the tile specified.

.. note::

  by elfyyy

*)
function R_OnTile(TP:Tpoint):Boolean;
var
  Loc: TPoint;
begin
  result := False;
  Loc := R_GetTileGlobal
  if Loc = TP then
    Result := True;
end;

(*
Point3D
~~~~~~~~~~~

.. code-block:: pascal

    function Point3D(x, y, z: Extended): TPoint3D;


.. note::

  by ReadySteadyGo

*)
function Point3D(x, y, z: Extended): TPoint3D;
begin
  Result.x := x;
  Result.y := y;
  Result.z := z;
end;

(*
Rotation
~~~~~~~~~~~

.. code-block:: pascal

    function Rotation(xpheta, ypheta, zpheta: Extended): TRotation;


.. note::

  by ReadySteadyGo

*)
function Rotation(xpheta, ypheta, zpheta: Extended): TRotation;
begin
  Result.x := xpheta;
  Result.y := ypheta;
  Result.z := zpheta;
end;

(*
Multiply_Point3D_Matrix3x3
~~~~~~~~~~~

.. code-block:: pascal

    function Multiply_Point3D_Matrix3x3(p: TPoint3D; m: TMatrix): TPoint3D;


.. note::

  by ReadySteadyGo

*)
function Multiply_Point3D_Matrix3x3(p: TPoint3D; m: TMatrix): TPoint3D;
begin
  Result.x := (m.Data[0] * p.x) + (m.Data[1] * p.y) + (m.Data[2] * p.z);
  Result.y := (m.Data[3] * p.x) + (m.Data[4] * p.y) + (m.Data[5] * p.z);
  Result.z := (m.Data[6] * p.x) + (m.Data[7] * p.y) + (m.Data[8] * p.z);
end;

(*
TranslatePoints3D
~~~~~~~~~~~

.. code-block:: pascal

    procedure TranslatePoints3D(var p: ATPoint3D; v: TPoint3D);


.. note::

  by ReadySteadyGo

*)
procedure TranslatePoints3D(var p: ATPoint3D; v: TPoint3D);
var
  Len, i: Integer;
begin
  Len := Length(p);
  for i := 0 to Len-1 do
    p[i] := Point3D(p[i].x + v.x, p[i].y + v.y, p[i].z + v.z);
end;

(*
RotatePoints3D
~~~~~~~~~~~

.. code-block:: pascal

    function RotatePoints3D(Points: ATPoint3D; rp: TPoint3D; r: TRotation): Array of TPoint3D;


.. note::

  by ReadySteadyGo

*)
function RotatePoints3D(Points: ATPoint3D; rp: TPoint3D; r: TRotation): Array of TPoint3D;
var
  m: TMatrix;
  Len, i: Integer;
begin
  R.x := radians(R.x);
  R.Y := radians(R.Y);
  r.z := radians(R.z);
  SetLength(m.Data, 9);
  m.Data := [Cos(r.y)*Cos(r.z), -Cos(r.x)*Sin(r.z) + Sin(r.x)*Sin(r.y)*Cos(r.z), Sin(r.x)*Sin(r.z)+Cos(r.x)*Sin(r.y)*Cos(r.z),
  Cos(r.y)*Sin(r.z), Cos(r.x)*Cos(r.z) + Sin(r.x)*Sin(r.y)*Sin(r.z), -Sin(r.x)*Cos(r.z)+Cos(r.x)*Sin(r.y)*Sin(r.z),
  -Sin(r.y), Sin(r.x)*Cos(r.y), Cos(r.x)*Cos(r.y)];
  Len := Length(Points);
  SetLength(Result, Len);
  TranslatePoints3D(Points, Point3D(-rp.x, -rp.y, -rp.z));
  for i := 0 to Len-1 do
    Result[i] := Multiply_Point3D_Matrix3x3(Points[i], m);
  TranslatePoints3D(Result, rp);
end;

(*
PerspectiveProject
~~~~~~~~~~~

.. code-block:: pascal

    function PerspectiveProject(p: ATPoint3D; cPos:TPoint3D): TPointArray;


.. note::

  by ReadySteadyGo

*)
function PerspectiveProject(p: ATPoint3D; cPos:TPoint3D): TPointArray;
var
  Len, i: Integer;
begin
  Len := Length(p);
  SetLength(Result, Len);
  for i := 0 to Len-1 do
  begin
    if (p[i].z - cPos.z) < 1 then
    begin
      Result[i].x:= 0;
      Result[i].y:= 0;
      Exit;
    end;
    Result[i].x:= Round((p[i].x - cPos.x) * {((512/2) / Tan(33/2))}864 / (p[i].z - cPos.z));
    Result[i].y:= Round((p[i].y - cPos.y) * {(512/2) / Tan(33/2)}864 / (p[i].z - cPos.z));
  end;
end;

(*
ProjectTile
~~~~~~~~~~~

.. code-block:: pascal

    function ProjectTile(var x, y: Integer; s: TScene; DrawColor{-1 to not Draw}: Integer): Boolean;


.. note::

  by ReadySteadyGo

*)
function ProjectTile(var x, y: Integer; s: TScene; DrawColor{-1 to not Draw}: Integer): Boolean;
var
  _3DPoints: ATPoint3D;
  _2DPoints: TPointArray;
  Len, i: Integer;
  MSBox: TBox;
  tp: TPoint3D;
begin
  if DrawColor = -1 then
    Len := 2
  else
    Len := 6;
  SetLength(_3DPoints, Len);
  SetLength(_2DPoints, Len);
  tp := s.TilePosition;
  _3DPoints[0] := s.PlayerTile;
  _3DPoints[1] := Point3D(tp.x + 6, tp.y + 12, tp.z + 6); // Center of input Tile
  if DrawColor <> -1 then
  begin
    _3DPoints[2] := Point3D(tp.x + 12, tp.y + 12, tp.z);
    _3DPoints[3] := Point3D(tp.x, tp.y + 12, tp.z);
    _3DPoints[4] := Point3D(tp.x + 12, tp.y + 12, tp.z + 12);
    _3DPoints[5] := Point3D(tp.x, tp.y + 12, tp.z + 12);
  end;
  TranslatePoints3D(_3DPoints, Point3D(-6, -6, 0));
  _3DPoints := RotatePoints3D(_3DPoints, _3DPoints[0], s.TileRotation);
  _3DPoints := RotatePoints3D(_3DPoints, s.CameraPosition, s.CameraRotation);
  _2DPoints := PerspectiveProject(_3DPoints, s.CameraPosition);
  MSBox.X1 := MSX1;
  MSBox.Y1 := MSY1;
  MSBox.X2 := MSX2;
  MSBox.Y2 := MSY2;
  for i := 0 to Len-1 do
  begin
    _2DPoints[i].x := _2DPoints[i].x + {(511/2) + 4}260;
    _2DPoints[i].y := _2DPoints[i].y + {(334/2) - 4}163;
    if not PointInBox(_2DPoints[i], MSBox) then
    begin
      Result := False;
      Exit;
    end;
  end;
  if DrawColor <> -1 then
  begin
    SMART_DrawLine(False, _2DPoints[2], _2DPoints[3], DrawColor);
    SMART_DrawLine(False, _2DPoints[4], _2DPoints[5], DrawColor);
    SMART_DrawLine(False, _2DPoints[3], _2DPoints[5], DrawColor);
    SMART_DrawLine(False, _2DPoints[2], _2DPoints[4], DrawColor);
  end;
  x := _2DPoints[1].x;
  y := _2DPoints[1].y;
  Result := True;
end;

(*
GetTile
~~~~~~~~~~~

.. code-block:: pascal

    function GetTile(var x, y: Integer; tx, tz: Integer; Draw: Boolean; Color: Integer): Boolean;


.. note::

  by ReadySteadyGo, Edited by Krazy Meerkat

*)
function GetTile(var x, y: Integer; tx, tz: Integer; Draw: Boolean; Color: Integer): Boolean;
var
  s: TScene;
begin
  with s do
  begin
    PlayerTile := Point3D(6, 20 + 12, (120) - 8 + 6);
    TilePosition := Point3D((tx*12)-(8*12), 23, (tz*12) + (24)-8);
    TileRotation := Rotation(0, (Round(R_GetMinimapAngleDeg)), 0);
    CameraPosition := Point3D(0, -233, 0);
    CameraRotation := Rotation(65, 0, 0);
  end;
  if (not Draw) then
    Color := -1;
  Result := ProjectTile(x, y, s, Color);
end;

(*
MMToMSTileEx
~~~~~~~~~~~

.. code-block:: pascal

    function MMToMSTileEx(var x, y: Integer; MMx, MMy:Integer; Draw: Boolean; Color: Integer): Boolean;


.. note::

  by ReadySteadyGo

*)
function MMToMSTileEx(var x, y: Integer; MMx, MMy:Integer; Draw: Boolean; Color: Integer): Boolean;
var
  p: TPoint;
begin
  p := RotatePoint(Point(MMx, MMy), R_GetMinimapAngleRad, MMCX, MMCY);
  p.x := Floor((p.x - (MMCX - 33)) / 4.0);
  p.y := 17- Floor((p.y - (MMCY - 37)) / 4.0);
  Result := GetTile(x, y, p.x, p.y, Draw, Color);
end;

(*
MMToMSTile
~~~~~~~~~~~

.. code-block:: pascal

    function MMToMSTile(var x, y: Integer; MMx, MMy:Integer; Draw: Boolean; Color: Integer): Boolean;


.. note::

  by ReadySteadyGo

*)
function MMToMSTile(var x, y: Integer; MMx, MMy: Integer): Boolean;
begin
  Result := MMToMSTileEx(x, y, MMx, MMy, False, 0);
end;

(*
GetMMToMSTile
~~~~~~~~~~~

.. code-block:: pascal

    function GetMMToMSTile(var x, y: Integer; MMx, MMy: Integer): TPoint;


.. note::

  by Krazy Meerkat

*)
function GetMMToMSTile(var x, y: Integer; MMx, MMy: Integer): TPoint;
var
  p: TPoint;
begin
  p := RotatePoint(Point(MMx, MMy), 0-R_GetMinimapAngleRad, MMCX, MMCY);
  p.x := Floor((p.x - (MMCX - 33)) / 4.0);
  p.y := 17- Floor((p.y - (MMCY - 37)) / 4.0);
  GetTile(x, y, p.x, p.y, False, 0);
  Result := Point(x,y);
end;

(*
R_TileToMs
~~~~~~~~~~~

.. code-block:: pascal

    function R_TileToMs(Tp: Tpoint): Tpoint;

    Converts a Tile Onscreen into a Tpoint coord on mainscreen

.. note::

  by ReadySteadyGo, Edited by Krazy Meerkat

*)
function R_TileToMs(Tp: Tpoint): Tpoint;
var
  x,y: integer;
  One: Tpoint;
begin
  Tp.x:= Tp.x + 1;
  Tp.y:= Tp.y - 1;
  One := R_TileToMM(Tp);
  Result := GetMMToMSTile(x, y, one.x, one.y);
end;

(*
R_WalkToPointMS
~~~~~~~~~~~

.. code-block:: pascal

    function R_WalkToPointMS(Tp: Tpoint): Boolean;

    Converts a Tile Onscreen into a Tpoint coord on mainscreen and
    Clicks on tile.

.. note::

  by elfyyy, edited by Krazy Meerkat

*)
function R_WalkToPointMS(Tp: Tpoint): Boolean;
var
  Me, Curr: Tpoint;
  timeout: Integer;
begin
  Curr := R_GetTileGlobal;
  if Curr = Tp then
    exit;
  result := false;
  Me := R_TileToMs(Tp);
  AL_MissMouse(Me,2,2);
  wait(randomrange(220,380));
  ClickMouse2(Mouse_Left);
  timeout:= 0;
  repeat
  Wait(100);
  if not(AL_playerWalking) then
    timeout:= 100;
  Inc(timeout);
  until(timeout > 99);
  result := (R_GetTileGlobal = Tp)
end;


