{$include_once R_DDSolve.simba}
{$include_once R_ForesterSolve.simba}
{$include_once R_MazeSolve.simba}
{$include_once R_MimeSolve.simba}
{$include_once R_PrisonPeteSolve.simba}

type
  R_Random = record
    RandName: String;
    SolveRandom, DetectRandom: function(): Boolean;
    Solved, Failed: Integer;
end;

var
  R_Randoms : array[0..13] of R_Random;
  R_CombatRandoms, R_Reincarnate: Boolean;
  R_RunAwayDirection: String;
  R_Deaths, R_TalksSolved, R_TalksFailed: Integer;

(*
R_SetupRandoms
~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure R_SetupRandoms;
  
Sets up all need info for Reflection Randoms

.. note::

  by Krazy Meerkat

*)
procedure R_SetupRandoms;
var
  i: Integer;
begin
  R_RunAwayDirection := 'random';
  R_Reincarnate := False;
  R_CombatRandoms := True;
  for i:= 0 to high(R_Randoms) do
  begin
    case i of
      0:
      begin
        R_Randoms[i].RandName := 'Mime';
        R_Randoms[i].DetectRandom := @R_DetectMime;
        R_Randoms[i].SolveRandom := @R_SolveMime; //Solved
      end;
      1:
      begin
        R_Randoms[i].RandName := 'Drill Demon';
        R_Randoms[i].DetectRandom := @R_DetectDD;
        R_Randoms[i].SolveRandom := @R_SolveDD; //Solved
      end;
      2:
      begin
        R_Randoms[i].RandName := 'Prison Pete';
        R_Randoms[i].DetectRandom := @R_DetectPrisonPete;
        R_Randoms[i].SolveRandom := @R_SolvePrisonPete; //Detection only
      end;
      3:
      begin
        R_Randoms[i].RandName := 'Maze';
        R_Randoms[i].DetectRandom := @R_DetectMaze;
        R_Randoms[i].SolveRandom := @R_SolveMaze; //Detection only
      end;
      4:
      begin
        R_Randoms[i].RandName := 'Evil Bob';
        R_Randoms[i].DetectRandom := @EB_Detect;
        R_Randoms[i].SolveRandom := @EB_Solve; //SRL Solver for now
      end;
      5:
      begin
        R_Randoms[i].RandName := 'Mordaut';
        R_Randoms[i].DetectRandom := @MD_Detect;
        R_Randoms[i].SolveRandom := @MD_Solve; //SRL Solver for now
      end;
      6:
      begin
        R_Randoms[i].RandName := 'Abyss';
        R_Randoms[i].DetectRandom := @Abyss_Detect;
        R_Randoms[i].SolveRandom := @Abyss_Solve; //SRL Solver for now
      end;
      7:
      begin
        R_Randoms[i].RandName := 'Pinball';
        R_Randoms[i].DetectRandom := @PB_Detect;
        R_Randoms[i].SolveRandom := @PB_Solve; //SRL Solver for now
      end;
      8:
      begin
        R_Randoms[i].RandName := 'Pillory Cage';
        R_Randoms[i].DetectRandom := @PL_Detect;
        R_Randoms[i].SolveRandom := @PL_Solve; //SRL Solver for now
      end;
      9:
      begin
        R_Randoms[i].RandName := 'Quiz Master';
        R_Randoms[i].DetectRandom := @Quiz_Detect;
        R_Randoms[i].SolveRandom := @Quiz_Solve; //SRL Solver for now
      end;
      10:
      begin
        R_Randoms[i].RandName := 'Beekeeper';
        R_Randoms[i].DetectRandom := @BK_Detect;
        R_Randoms[i].SolveRandom := @BK_Solve; //SRL Solver for now
      end;
      11:
      begin
        R_Randoms[i].RandName := 'Rewards';
        R_Randoms[i].DetectRandom := @RD_Detect;
        R_Randoms[i].SolveRandom := @RD_Solve; //SRL Solver for now
      end;
      12:
      begin
        R_Randoms[i].RandName := 'Freaky Forester';
        R_Randoms[i].DetectRandom := @R_DetectForester;
        R_Randoms[i].SolveRandom := @R_SolveForester; //SRL Solver for now
      end;
    end;
  end;
end;

(*
R_FindDead
~~~~~~~~~~

.. code-block:: pascal

  function R_FindDead: Boolean;
  
Returns True if player is dead unless R_Reincarnate = True

.. note::

  by elfyyy

*)
function R_FindDead: Boolean;
begin
  if R_Reincarnate then
    Result := False
  else
  Result := (R_GetHealth = 0);
  if Result then begin
    writeln('[Reflection Anti-Randoms] Detected we are dead, logging out.');
    Inc(R_Deaths);
    Wait(15000);
    logout;
    players[currentPlayer].active := false;
  end;
end;

(*
R_FindCombatRandom
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function R_FindCombatRandom: boolean;
  
Returns True if player is in a Combat random.

.. note::

  by elfyyy

*)
function R_FindCombatRandom: boolean;
var
  Names: TStringArray;
  Temp: TNPC;
begin
  Result := False;
  Names := ['security', 'evil chicken', 'river troll', 'rock golem', 'shade', 'swarm', 'zombie', 'tree spirit', 'ent'];
  Temp := R_InteractingNPC;
  if (StrInArr(Lowercase(Temp.Name), Names)) then
    Result := True;
  if Result then
    writeln('[Reflection Anti-Randoms] Combat random detected! Running away...');
end;

(*
R_FindTalk
~~~~~~~~~~

.. code-block:: pascal

  function R_FindTalk: Boolean;
  
Solves all talking randoms.

.. note::

  by elfyyy

*)
function R_FindTalk: Boolean;
var
  Temp: TNPCArray;
  Temp1: TNPC;
  RandList: TStringArray;
  i, f: integer;
  FoundNPC, FrogPrincess: TNPC;
  Loc, StartLoc: Tpoint;
  PName: String;
begin
  Result := False;
  RandList := ['frog', 'certer', 'drunken dwarf', 'genie', 'highwayman', 'dr jekyll', 'pirate', 'security', 'rick turpentine','mysterious old man'];
  Temp := R_GetAllNPCs;
  for i := 0 to High(Temp) do
    if (StrInArr(Lowercase(Temp[i].Name), RandList)) then begin
      PName := lowercase(R_GetPlayerName);
      MarkTime(f);
      if Pos('frog', Lowercase(Temp[i].Name)) <= 0 then begin
        while Pos(PName, Lowercase(Temp1.OverHeadText)) <= 0 do begin
          R_FindNPC(Temp[i].Name, Temp1);
          wait(200);
          if TimeFromMark(f) > 10000 then
            exit;
        end;
        Result := True;
        StartLoc := R_GetTileGlobal;
        writeln('[Reflection Anti-Randoms] '+Temp[i].Name+' random detected! Solving...');
        R_FindNPC(Temp[i].Name, FoundNPC);
        Loc := FoundNPC.Tile;
        Loc := R_TileToMs(Loc);
        Mmouse(Loc.x, Loc.y, 0, 0);
        if R_WaitUptext(FoundNPC.Name, 200) then begin
          ClickMouse2(Mouse_Left);
          Wait(RandomRange(1000, 1800));
          DoConversation('', True);
        end;
        if R_NearTile(StartLoc, 20) then begin
          writeln('[Reflection Anti-Randoms] '+Temp[i].Name+' random Solved!');
          Inc(R_TalksSolved);
          exit;
        end else begin
          writeln('[Reflection Anti-Randoms] '+Temp[i].Name+' random failed! Logging out...');
          Inc(R_TalksFailed);
          logout;
          players[currentPlayer].active := false;
        end;
      end else begin
        writeln('[Reflection Anti-Randoms] '+Temp[i].Name+' random detected! Solving...');
        R_FindNpc('Princess', FrogPrincess);
        while Pos(PName, FrogPrincess.OverHeadText) <> 0 do begin
          wait(200);
          if TimeFromMark(f) > 10000 then
            exit;
      end;
      R_FindNpc('Princess', FrogPrincess);
      Result := True;
      Loc := FrogPrincess.Tile;
      Loc := R_TileToMs(Loc);
      Mmouse(Loc.x, Loc.y, 0, 0);
      if R_WaitUptext('rincess', 200) then begin
        ClickMouse2(Mouse_Left);
        Wait(5000);
        ClickToContinue;
        ChatWait;
        FindNPCChatTextMulti(['very','orry','hange','lrigh','Okay','kay.','I supp','pose so','yeah','Yeah','Sure','ure'], Clickleft);
        ChatWait;
        ClickToContinue;
        ChatWait;
        FindNPCChatTextMulti(['very','orry','hange','lrigh','Okay','kay.','I supp','pose so','yeah','Yeah','Sure','ure'], Clickleft);
        ClickToContinue;
        ClickToContinue;
      end;
    end;
  end;
end;

(*
R_FindNormalRandoms
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function R_FindNormalRandoms: Boolean;
  
Solves all Randoms using Reflection first, and SRL solvers second

.. note::

  by Krazy Meerkat, elfyyy, & Frement

*)
function R_FindNormalRandoms: Boolean;
var
  i: integer;
begin
  Result := False;
  for i := 0 to high(R_Randoms) do
  begin
    if ({$IFDEF Lape}@{$ENDIF}R_Randoms[i].DetectRandom <> nil) and (R_Randoms[i].DetectRandom()) then
    begin
      Result := True;
      writeln('[Reflection Anti-Randoms] '+R_Randoms[i].RandName+' random detected! Solving...');
    if ({$IFDEF Lape}@{$ENDIF}R_Randoms[i].SolveRandom <> nil) and (R_Randoms[i].SolveRandom()) then
      begin
        writeln('[Reflection Anti-Randoms] Solved '+R_Randoms[i].RandName+' random!');
        Inc(R_Randoms[i].Solved);
        Exit;
      end else
      begin
        writeln('[Reflection Anti-Randoms] Failed '+R_Randoms[i].RandName+' random, logging out.');
        Inc(R_Randoms[i].Failed);
        players[currentPlayer].active := false;
        logout;
        Exit;
      end;
    end;
  end;
  if R_CombatRandoms then
    if R_FindCombatRandom then begin
      R_RunAway(R_RunAwayDirection, 30, True);
        Exit;
      end;
  if (R_Return(Result, @R_FindTalk)) then
    Exit;
  if (R_Return(Result, @FindMod)) then
    Exit;
  if (R_Return(Result, @R_FindDead)) then
    Exit;
end;

(*
R_FNRWait
~~~~~~~~~

.. code-block:: pascal

  function R_FNRWait(Time, WaitPerLoop: integer): Boolean;
  
Used instead of Wait() or Sleep() and checks for Reflection Randoms.
WaitPerLoop is the time frequancy to check for randoms. 50-100 is average.

.. note::

  by elfyyy

*)
function R_FNRWait(Time, WaitPerLoop: integer): Boolean;
var
  StartTime: integer;
begin
  Result := False;
  MarkTime(StartTime);
  while (not result) and (GetSystemTime - StartTime < Time) do begin
    Result := R_FindNormalRandoms;
    wait(WaitPerLoop);
  end;
end;
