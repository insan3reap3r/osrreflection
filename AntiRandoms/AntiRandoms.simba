{$include_once R_DDSolve.simba}
{$include_once R_ForesterSolve.simba}
{$include_once R_MazeSolve.simba}
{$include_once R_MimeSolve.simba}
{$include_once R_PrisonPeteSolve.simba}
{$include_once R_FrogSolve.simba}

type
  R_Random = record
    RandName: String;
    SolveRandom, DetectRandom: function(): Boolean;
    Solved, Failed: Integer;
end;

var
  R_Randoms : array[0..13] of R_Random;
  R_CombatRandoms, R_Reincarnate: Boolean;
  R_RunAwayDirection: String;
  R_Deaths: Integer;

{$include_once R_TalkRandoms.simba}

(*
R_SetupRandoms
~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure R_SetupRandoms;

Sets up all need info for Reflection Randoms

.. note::

  by Krazy Meerkat

*)
procedure R_SetupRandoms;
var
  i: Integer;
begin
  R_RunAwayDirection := 'random';
  R_Reincarnate := False;
  R_CombatRandoms := True;
  for i:= 0 to high(R_Randoms) do
  begin
    case i of
      0:
      begin
        R_Randoms[i].RandName := 'Mime';
        R_Randoms[i].DetectRandom := @R_DetectMime;
        R_Randoms[i].SolveRandom := @R_SolveMime; //Solved
      end;
      1:
      begin
        R_Randoms[i].RandName := 'Drill Demon';
        R_Randoms[i].DetectRandom := @R_DetectDD;
        R_Randoms[i].SolveRandom := @R_SolveDD; //Solved
      end;
      2:
      begin
        R_Randoms[i].RandName := 'Prison Pete';
        R_Randoms[i].DetectRandom := @R_DetectPrisonPete;
        R_Randoms[i].SolveRandom := @R_SolvePrisonPete; //Detection only
      end;
      3:
      begin
        R_Randoms[i].RandName := 'Maze';
        R_Randoms[i].DetectRandom := @R_DetectMaze;
        R_Randoms[i].SolveRandom := @R_SolveMaze; //Detection only
      end;
      4:
      begin
        R_Randoms[i].RandName := 'Evil Bob';
        R_Randoms[i].DetectRandom := @EB_Detect;
        R_Randoms[i].SolveRandom := @EB_Solve; //SRL Solver for now
      end;
      5:
      begin
        R_Randoms[i].RandName := 'Mordaut';
        R_Randoms[i].DetectRandom := @MD_Detect;
        R_Randoms[i].SolveRandom := @MD_Solve; //SRL Solver for now
      end;
      6:
      begin
        R_Randoms[i].RandName := 'Abyss';
        R_Randoms[i].DetectRandom := @Abyss_Detect;
        R_Randoms[i].SolveRandom := @Abyss_Solve; //SRL Solver for now
      end;
      7:
      begin
        R_Randoms[i].RandName := 'Pinball';
        R_Randoms[i].DetectRandom := @PB_Detect;
        R_Randoms[i].SolveRandom := @PB_Solve; //SRL Solver for now
      end;
      8:
      begin
        R_Randoms[i].RandName := 'Pillory Cage';
        R_Randoms[i].DetectRandom := @PL_Detect;
        R_Randoms[i].SolveRandom := @PL_Solve; //SRL Solver for now
      end;
      9:
      begin
        R_Randoms[i].RandName := 'Quiz Master';
        R_Randoms[i].DetectRandom := @Quiz_Detect;
        R_Randoms[i].SolveRandom := @Quiz_Solve; //SRL Solver for now
      end;
      10:
      begin
        R_Randoms[i].RandName := 'Beekeeper';
        R_Randoms[i].DetectRandom := @BK_Detect;
        R_Randoms[i].SolveRandom := @BK_Solve; //SRL Solver for now
      end;
      11:
      begin
        R_Randoms[i].RandName := 'Rewards';
        R_Randoms[i].DetectRandom := @RD_Detect;
        R_Randoms[i].SolveRandom := @RD_Solve; //SRL Solver for now
      end;
      12:
      begin
        R_Randoms[i].RandName := 'Freaky Forester';
        R_Randoms[i].DetectRandom := @R_DetectForester;
        R_Randoms[i].SolveRandom := @R_SolveForester; //SRL Solver for now
      end;
      13:
      begin
        R_Randoms[i].RandName := '';
        R_Randoms[i].DetectRandom := @R_FindTalk;
        R_Randoms[i].SolveRandom := @R_SolveTalk;
      end;
      14:
      begin
        R_Randoms[i].RandName := 'Frog';
        R_Randoms[i].DetectRandom := @R_FindFrog;
        R_Randoms[i].SolveRandom := @R_SolveFrog;
      end;
    end;
  end;
end;

(*
R_FindDead
~~~~~~~~~~

.. code-block:: pascal

  function R_FindDead: Boolean;

Returns True if player is dead unless R_Reincarnate = True

.. note::

  by elfyyy

*)
function R_FindDead: Boolean;
begin
  Result := (R_GetHealth = 0);
  if Result then begin
    writeln('[Reflection Anti-Randoms] Detected we are dead, logging out.');
    Inc(R_Deaths);
    if (not R_Reincarnate) then begin
      Wait(15000);
      LogOut;
      Players[CurrentPlayer].Active := False;
    end;
  end;
end;

(*
R_FindCombatRandom
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function R_FindCombatRandom: boolean;

Returns True if player is in a Combat random.

.. note::

  by elfyyy

*)
function R_FindCombatRandom: boolean;
var
  Names: TStringArray;
  Temp: TNPCArray;
  FoundNpc: TNPC;
  i: integer;
begin
  Result := False;
  if (not R_UnderAttack) then
    exit;
  Names := ['security guard', 'evil chicken', 'river troll', 'rock golem', 'shade', 'swarm', 'zombie', 'tree spirit', 'ent'];
  Temp := R_GetAllNpcs;
  for i := 0 to high(Temp) do
  if (ExactStrInArr(Lowercase(Temp[i].Name), Names)) then
  begin
    R_FindNpc(Temp[i].Name, FoundNpc);
    if (not R_NearTile(FoundNpc.Tile, 10)) then
      exit
    else
      Result := True;
  end;
  if Result then
    writeln('[Reflection Anti-Randoms] ''' + (FoundNpc.Name) + ''' Combat random detected! Running away...');
end;

(*
R_FindNormalRandoms
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function R_FindNormalRandoms: Boolean;

Solves all Randoms using Reflection first, and SRL solvers second

.. note::

  by Krazy Meerkat, elfyyy, & Frement

*)
function R_FindNormalRandoms: Boolean;
var
  i: integer;
begin
  Result := False;
  for i := 0 to high(R_Randoms) do
  begin
    if ({$IFDEF Lape}@{$ENDIF}R_Randoms[i].DetectRandom <> nil) and (R_Randoms[i].DetectRandom()) then
    begin
      Result := True;
      writeln('[Reflection Anti-Randoms] '+R_Randoms[i].RandName+' random detected! Solving...');
    if ({$IFDEF Lape}@{$ENDIF}R_Randoms[i].SolveRandom <> nil) and (R_Randoms[i].SolveRandom()) then
      begin
        writeln('[Reflection Anti-Randoms] Solved '+R_Randoms[i].RandName+' random!');
        Inc(R_Randoms[i].Solved);
        Exit;
      end else
      begin
        writeln('[Reflection Anti-Randoms] Failed '+R_Randoms[i].RandName+' random, logging out.');
        Inc(R_Randoms[i].Failed);
        players[currentPlayer].active := false;
        logout;
        Exit;
      end;
    end;
  end;
  if R_CombatRandoms then
    if R_FindCombatRandom then begin
      R_RunAway(R_RunAwayDirection, 30, True);
        Exit;
      end;
  if (R_Return(Result, @FindMod)) then
    Exit;
  if (R_Return(Result, @R_FindDead)) then
    Exit;
end;

(*
R_FNRWait
~~~~~~~~~

.. code-block:: pascal

  function R_FNRWait(Time, WaitPerLoop: integer): Boolean;

Used instead of Wait() or Sleep() and checks for Reflection Randoms.
WaitPerLoop is the time frequancy to check for randoms. 50-100 is average.

.. note::

  by elfyyy

*)
function R_FNRWait(Time, WaitPerLoop: integer): Boolean;
var
  StartTime: integer;
begin
  Result := False;
  MarkTime(StartTime);
  while (not result) and (GetSystemTime - StartTime < Time) do begin
    Result := R_FindNormalRandoms;
    wait(WaitPerLoop);
  end;
end;
